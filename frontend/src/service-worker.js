/* eslint-disable no-restricted-globals */
import { clientsClaim } from "workbox-core";
import { ExpirationPlugin } from "workbox-expiration";
import { precacheAndRoute, createHandlerBoundToURL } from "workbox-precaching";
import { registerRoute } from "workbox-routing";
import { NetworkFirst, NetworkOnly, StaleWhileRevalidate } from "workbox-strategies";

clientsClaim();

// Precache all assets generated by the production build.
precacheAndRoute(self.__WB_MANIFEST);

// App shell fallback for client-side routing (react-router-dom).
const fileExtensionRegexp = new RegExp("/[^/?]+\\.[^/]+$");
registerRoute(
  ({ request, url }) => {
    if (request.mode !== "navigate") {
      return false;
    }
    if (url.pathname.startsWith("/_")) {
      return false;
    }
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }
    return true;
  },
  createHandlerBoundToURL(`${process.env.PUBLIC_URL}/index.html`),
);

// Runtime caching for same-origin static assets.
registerRoute(
  ({ request, url }) =>
    url.origin === self.location.origin &&
    ["script", "style", "worker", "image", "font"].includes(request.destination),
  new StaleWhileRevalidate({
    cacheName: "static-runtime-assets",
    plugins: [
      new ExpirationPlugin({
        maxEntries: 150,
        maxAgeSeconds: 30 * 24 * 60 * 60,
      }),
    ],
  }),
);

// Never cache auth/session endpoints to avoid stale identity state.
registerRoute(
  ({ url }) =>
    url.origin.endsWith(".supabase.co") && url.pathname.startsWith("/auth/v1/"),
  new NetworkOnly(),
);

// Network-first API strategy for Supabase runtime data.
registerRoute(
  ({ url, request }) =>
    request.method === "GET" &&
    url.origin.endsWith(".supabase.co") &&
    (url.pathname.startsWith("/rest/v1/") ||
      url.pathname.startsWith("/functions/v1/")),
  new NetworkFirst({
    cacheName: "supabase-api-network-first",
    networkTimeoutSeconds: 8,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 40,
        maxAgeSeconds: 5 * 60,
      }),
    ],
  }),
);

self.addEventListener("message", (event) => {
  if (event.data && event.data.type === "SKIP_WAITING") {
    self.skipWaiting();
  }
});
